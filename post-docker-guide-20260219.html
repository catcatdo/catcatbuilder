<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker 기초 - 개발 환경을 컨테이너로 관리하기 | 릴황 블로그</title>
    <meta name="description" content="Docker 기초부터 실전까지. 개발 환경 통일, 배포 자동화, 컨테이너 관리까지 실용적인 가이드와 팁">
    <meta property="og:title" content="Docker 기초 - 개발 환경을 컨테이너로 관리하기">
    <meta property="og:description" content="Docker 기초부터 실전까지. 개발 환경 통일, 배포 자동화, 컨테이너 관리까지 실용적인 가이드와 팁">
    <meta property="og:image" content="images/post-docker-guide-20260219.jpg">
    <link rel="stylesheet" href="blog.css">
</head>
<body>
    <article class="blog-post">
        <header class="post-header">
            <h1>Docker 기초 - 개발 환경을 컨테이너로 관리하기</h1>
            <div class="post-meta">
                <span class="date">2026-02-19</span>
                <span class="category">기술</span>
                <span class="author">릴황</span>
            </div>
        </header>
        
        <img src="images/post-docker-guide-20260219.jpg" alt="Docker 컨테이너 개념 이미지" class="post-image">
        
        <div class="post-content">
            <h2>왜 Docker를 써야 할까?</h2>
            <p>개발자들이 가장 많이 하는 고민 중 하나가 "내 컴퓨터에서는 되는데 왜 서버에서는 안 되지?"야. 이 말의 의미는 다들 알 거야. 로컬에서는 잘 돌아가던 코드가 배포 환경에서 에러를 뿜어낼 때의 그 답답함. 이 문제의 원인은 대부분 환경 차이 때문이거든.</p>
            
            <p>내 노트북에서는 Node.js 18이 설치되어 있는데, 서버에는 16이 깔려 있으면? 로컬에서 테스트할 때 쓴 라이브러리 버전과 서버의 버전이 다른다면? 운영체제 설정이 조금이라도 다르다면? 이런 작은 차이들이 쌓여서 "잘 되던 게" 갑자기 "안 되는" 상황이 발생하는 거야.</p>
            
            <p>Docker는 바로 이 문제를 해결해주는 도구야. 애플리케이션과 그에 필요한 모든 것(운영체제, 런타임, 라이브러리, 설정 파일 등)을 하나의 "컨테이너"라는 단위로 패키징해서 어디서든 똑같이 실행할 수 있게 해주거든. 내 노트북에서 실행한 것과 서버에서 실행한 것이 100% 동일한 환경에서 돌아간다는 거야.</p>
            
            <p>나도 Docker를 처음 접했을 때는 "또 배워야 하는 게 생겼네" 싶었어. 근데 한번 쓰기 시작하니까 왜 사람들이 이걸 쓰는지 알겠더라고. 특히 팀 프로젝트를 할 때 진가가 발휘돼. 팀원 A는 맥을 쓰고, 팀원 B는 윈도우를 쓰고, 팀원 C는 리눅스를 쓰는데, Docker를 쓰면 모두가 완전히 똑같은 환경에서 개발할 수 있거든.</p>
            
            <p>오늘은 Docker의 기본 개념부터 실전에서 꼭 쓰는 명령어, 그리고 자주 하는 실수와 해결법까지 모두 정리해서 알려줄게. 이 글을 다 읽으면 당장 오늘부터 Docker로 개발 환경을 관리할 수 있을 거야.</p>
            
            <h2>Docker의 핵심 개념 이해하기</h2>
            <p>Docker를 이해하려면 두 가지 핵심 개념을 알아야 해: 이미지(Image)와 컨테이너(Container). 이 둘의 관계를 잘 이해하는 게 Docker 마스터의 첫걸음이야.</p>
            
            <p>이미지는 마치 클래스(Class)와 같아. 애플리케이션을 실행하는 데 필요한 모든 것이 담긴 "설계도" 같은 거야. 운영체제 베이스(우분투, 알파인 등), 런타임(Node.js, Python, Java 등), 애플리케이션 코드, 환경 변수, 설정 파일들이 모두 포함되어 있거든. 이미지는 읽기 전용이고 변경할 수 없어.</p>
            
            <p>컨테이너는 이미지를 기반으로 실행된 실제 프로세스야. 클래스에서 객체를 생성하듯, 이미지에서 컨테이너를 생성하는 거지. 하나의 이미지로 여러 개의 컨테이너를 실행할 수 있어. 각 컨테이너는 독립적인 환경에서 실행되고, 서로 간섭하지 않거든.</p>
            
            <p>Dockerfile은 이미지를 만드는 "레시피"야. 어떤 베이스 이미지를 쓸지, 어떤 파일을 복사할지, 어떤 명령어를 실행할지, 어떤 포트를 열어둘지 등을 적어두는 파일이지. 이 파일을 docker build 명령어로 실행하면 이미지가 생성돼.</p>
            
            <p>docker-compose는 여러 컨테이너를 한꺼번에 관리하는 도구야. 실제 서비스는 보통 애플리케이션 서버, 데이터베이스, 캐시 서버 등 여러 컴포넌트로 구성되거든. 이걸 하나씩 docker run으로 실행하면 번거로우니까, docker-compose.yml 파일에 정의핵돼 한 번에 실행하고 관리할 수 있게 해주는 거야.</p>
            
            <p>볼륨(Volume)은 컨테이너의 데이터를 영구 저장하는 방법이야. 컨테이너는 원래 상태가 변하지 않는 것을 전제로 설계됐거든. 컨테이너를 삭제하면 안의 데이터도 다 사라져. 그래서 데이터베이스 파일이나 로그 파일 같이 유지해야 하는 데이터는 볼륨으로 호스트 머신에 저장핸는 거야.</p>
            
            <h2>Docker 설치와 첫 컨테이너 실행</h2>
            <p>먼저 Docker를 설치해야 해. 공식 홈페이지(docker.com)에서 자신의 운영체제에 맞는 Docker Desktop을 다운로드하면 돼. 설치가 완료되면 터미널에서 docker --version을 입력해서 제대로 설치됐는지 확인핸지.</p>
            
            <p>설치가 끝났으면 간단한 테스트를 핸보자. docker run hello-world라고 입력핸지. 이 명령어는 Docker Hub라는 공개 이미지 저장소에서 hello-world 이미지를 다운로드하고 실행하는 거야. 실행되면 Docker의 작동 원리에 대한 설명이 출력될 거야.</p>
            
            <p>이제 실제로 쓸 만한 컨테이너를 실행핸보자. docker run -d -p 8080:80 nginx라고 입력핸지. 이 명령어는 nginx 웹 서버를 백그라운드(-d)로 실행하고, 컨테이너의 80번 포트를 호스트의 8080번 포트와 연결(-p)하는 거야. 실행 후 브라우저에서 localhost:8080에 접속하면 nginx의 기본 페이지가 뜰 거야.</p>
            
            <p>docker ps 명령어로 실행 중인 컨테이너 목록을 확인할 수 있어. 컨테이너 ID, 이미지 이름, 실행 시간, 포트 매핑 정보 등이 표시돼. docker ps -a라고 하면 중지된 컨테이너도 포함해서 모두 볼 수 있거든.</p>
            
            <p>컨테이너를 중지하려면 docker stop [컨테이너ID]라고 해. ID는 docker ps에서 확인한 것의 앞 3~4글자만 써도 돼. 다시 시작하려면 docker start [컨테이너ID]를 사용하고, 완전히 삭제하려면 docker rm [컨테이너ID]를 쓰면 돼. 참고로 실행 중인 컨테이너는 먼저 중지해야 삭제할 수 있어.</p>
            
            <h2>자신만의 이미지 만들기</h2>
            <p>남의 이미지를 쓰는 것도 좋지만, 결국 자신의 애플리케이션을 담은 이미지를 만들어야 해. 이제 Node.js 애플리케이션을 Docker 이미지로 만드는 방법을 알려줄게.</p>
            
            <p>프로젝트 루트에 Dockerfile이라는 이름의 파일을 만들어. 내용은 다음과 같이 작성해:</p>
            
            <pre><code># 베이스 이미지 선택
FROM node:18-alpine

# 작업 디렉토리 설정
WORKDIR /app

# package.json과 package-lock.json 복사
COPY package*.json ./

# 의존성 설치
RUN npm install

# 애플리케이션 코드 복사
COPY . .

# 포트 노출
EXPOSE 3000

# 애플리케이션 실행
CMD ["node", "server.js"]</code></pre>
            
            <p>각 줄의 의미를 설명해줄게. FROM은 기반이 되는 이미지를 지정하는 거야. node:18-alpine은 Node.js 18이 설치된 알파인 리눅스를 쓰겠다는 의미거든. alpine은 가벼운 리눅스 배포판이라 이미지 크기를 작게 유지할 수 있어.</p>
            
            <p>WORKDIR은 컨테이너 안의 작업 디렉토리를 설정하는 거야. 이후의 모든 명령어는 이 디렉토리를 기준으로 실행돼. COPY는 호스트 머신의 파일을 컨테이너로 복사하는 명령어야. package*.json은 package.json과 package-lock.json을 모두 복사하는 패턴이지.</p>
            
            <p>RUN은 이미지를 빌드할 때 실행할 명령어야. npm install로 의존성을 설치하는 거지. RUN 명령어는 이미지 빌드 시 한 번 실행되고, 이미지에 결과가 저장돼. CMD는 컨테이너가 시작될 때 실행할 명령어야. 이미지당 하나만 가질 수 있거든.</p>
            
            <p>이제 이미지를 빌드핸보자. docker build -t my-app:1.0 .이라고 입력핸지. -t는 이미지에 이름과 태그를 붙이는 옵션이야. 마지막의 점(.)은 현재 디렉토리의 Dockerfile을 사용하겠다는 의미거든. 빌드가 완료되면 docker images로 만들어진 이미지를 확인할 수 있어.</p>
            
            <p>이미지를 실행핸보자. docker run -d -p 3000:3000 --name my-container my-app:1.0이라고 입력핸지. --name으로 컨테이너 이름을 지정할 수 있어. 이렇게 하면 docker ps에서 컨테이너 ID 대신 이름으로 확인할 수 있거든. docker logs my-container로 로그를 확인하고, docker exec -it my-container /bin/sh로 컨테이너 낶으로 들어갈 수도 있어.</p>
            
            <h2>docker-compose로 여러 서비스 관리하기</h2>
            <p>실제 애플리케이션은 보통 데이터베이스도 필요하고, 캐시 서버도 필요해. 이럴 때 docker-compose를 쓰면 한 번에 관리할 수 있어. docker-compose.yml 파일을 작성하는 방법을 알려줄게.</p>
            
            <pre><code>version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=db
    depends_on:
      - db
    volumes:
      - ./logs:/app/logs

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:</code></pre>
            
            <p>services 아래에 각 컨테이너를 정의하는 거야. app은 우리가 만든 애플리케이션, db는 PostgreSQL 데이터베이스, redis는 Redis 캐시 서버지. 각 서비스에 build, image, ports, environment, volumes 등을 설정할 수 있어.</p>
            
            <p>depends_on은 서비스 간 의존 관계를 설정하는 거야. app이 db에 의존한다는 의미는 db가 먼저 시작된 후에 app이 시작된다는 거지. environment로 환경 변수를 설정하고, volumes으로 데이터를 영구 저장할 수 있어.</p>
            
            <p>docker-compose up -d로 모든 서비스를 백그라운드로 시작할 수 있어. docker-compose down으로 모두 중지하고 삭제할 수 있거든. docker-compose logs로 로그를 확인하고, docker-compose ps로 실행 상태를 볼 수 있어.</p>
            
            <h2>자주 하는 실수와 해결법</h2>
            <p>Docker를 처음 쓸 때 흔히 하는 실수들이 있어. 첫 번째는 이미지 크기를 신경 쓰지 않는 거야. 베이스 이미지로 ubuntu:latest를 쓰면 이미지가 수백 MB가 될 수 있거든. 가능한한 alpine이나 distroless 같은 가벼운 이미지를 쓰는 게 좋아. 이미지가 작으면 배포도 빠르고 저장 공간도 아낄 수 있어.</p>
            
            <p>두 번째는 Dockerfile의 레이어 캐싱을 이해 못 하는 거야. Dockerfile의 각 명령어는 레이어(layer)로 만들어지고, 변경되지 않은 레이어는 캐싱되어 재사용돼. 그래서 자주 변경되는 파일을 나중에 COPY하고, 자주 변경되지 않는 파일(의존성 파일 등)을 먼저 COPY하는 게 중요해. 그래야 빌드 속도가 빨라지거든.</p>
            
            <p>세 번째는 데이터 영속성을 고려하지 않는 거야. 컨테이너는 언제든지 삭제될 수 있거든. 그래서 데이터베이스 같은 경우 반드시 볼륨을 사용해서 데이터를 호스트에 저장해야 해. 그렇지 않으면 컨테이너를 삭제하는 순간 모든 데이터가 날아가거든.</p>
            
            <p>네 번째는 환경 변수 관리를 소홀히 하는 거야. 비밀번호나 API 키 같은 민감한 정보를 Dockerfile에 하드코딩하면 안 돼. 대신 .env 파일이나 런타임에 환경 변수를 주입하는 방식을 써야 해. docker run -e 옵션이나 docker-compose의 environment를 활용하거든.</p>
            
            <p>다섯 번째는 로그 관리를 안 하는 거야. 컨테이너가 쌓는 로그가 디스크를 가득 채울 수 있거든. 로그 로테이션을 설정하거나, 외부 로그 수집 시스템(ELK 스택 등)을 연결하는 게 좋아. Docker의 기본 로그 드라이버 설정도 확인핸지.</p>
            
            <h2>실전 팁과 최적화</h2>
            <p>멀티 스테이지 빌드를 활용하면 이미지 크기를 극적으로 줄일 수 있어. 빌드에 필요한 도구와 런타임에 필요한 것을 분리하는 거지. 예를 들어 Node.js 애플리케이션을 빌드할 때는 node:18 이미지를 쓰지만, 실행할 때는 node:18-alpine만 쓰는 식이야.</p>
            
            <p>.dockerignore 파일을 작성하면 불필요한 파일을 이미지에 포함하지 않을 수 있어. node_modules, .git, 로그 파일 등을 제외하면 이미지 크기가 작아지고 빌드 속도도 빨라져. .gitignore와 비슷한 문법으로 작성하면 돼.</p>
            
            <p>헬스체크를 설정하면 컨테이너의 상태를 모니터링할 수 있어. Dockerfile에 HEALTHCHECK 명령어를 추가하거나, docker-compose에 healthcheck 설정을 추가하면 돼. 애플리케이션이 제대로 응답하는지 주기적으로 체크하고, 문제가 있으면 자동으로 재시작되게 할 수 있거든.</p>
            
            <p>리소스 제한을 설정하면 한 컨테이너가 시스템 자원을 모두 독식하는 걸 방지할 수 있어. docker run에서 --memory, --cpus 옵션을 주거나, docker-compose에서 deploy.resources를 설정하면 돼. 프로덕션 환경에서는 반드시 설정해야 해.</p>
            
            <h2>마무리 - 오늘부터 Docker로 개발하기</h2>
            <p>오늘 Docker의 기본 개념부터 실전 활용법까지 알려줬어. 처음에는 낯설게 느껴질 수 있지만, 한두 번 써복볩금 손에 익을 거야. 특히 팀 프로젝트를 할 때 Docker를 쓰면 환경 설정 때문에 시간 낭비하는 일이 크게 줄어들거든.</p>
            
            <p>오늘 배운 내용을 정리핸지. 이미지와 컨테이너의 차이를 이해하고, Dockerfile로 이미지를 만들고, docker-compose로 여러 서비스를 관리하는 거야. 그리고 볼륨으로 데이터를 영구 저장하고, 환경 변수로 설정을 관리하는 거지.</p>
            
            <p>처음에는 간단한 애플리케이션 하나를 Docker로 실행핸보는 것부터 시작핸지. nginx나 httpd 같은 간단한 웹 서버로 연습핸도 좋아. 익숙해지면 자신의 프로젝트를 Docker화핸보고, 데이터베이스까지 연결핸보는 식으로 단계를 밟아가면 돼.</p>
            
            <p>Docker는 단순한 도구를 넘어 현대 개발의 표준으로 자리 잡았어. 클라우드 배포, CI/CD 파이프라인, 마이크로서비스 아키텍처 등 어디에나 Docker가 쓰이거든. Docker를 잘 쓰면 개발 환경의 일관성을 유지하고, 배포 프로세스를 자동화하고, 확장성 있는 시스템을 구축할 수 있어.</p>
            
            <p>추가로 궁금한 점이 있거나 에러가 해결되지 않으면 댓글로 물어봐줘. Docker 관련 팁이나 Kubernetes 같은 고급 주제도 더 써볼 수 있어. 그럼 오늘도 유익한 개발 되길 바랄게! 다음에는 Docker와 함께 쓰는 CI/CD 도구인 GitHub Actions에 대해 글을 써볼까 하는데, 관심 있으면 알려줘.</p>
        </div>
        
        <footer class="post-footer">
            <div class="tags">
                <span class="tag">Docker</span>
                <span class="tag">컨테이너</span>
                <span class="tag">개발환경</span>
                <span class="tag">DevOps</span>
                <span class="tag">배포</span>
            </div>
        </footer>
    </article>
</body>
</html>
