# Java 고성능 서비스에서 클래스로더 경합 문제 해결하기

## 개요

고성능 Java 애플리케이션을 운영하다 별면, 예상치 못한 성능 병목 현상을 마주치게 됩니다. 특히 높은 동시성 환경에서는 한 줄의 코드가 전체 시스템을 멈추게 만들 수도 있습니다. 오늘은 실제 운영 환경에서 발생한 클래스로더 경합 문제와 이를 해결한 방법을 공유합니다.

## 문제 상황

초당 800개 요청을 처리하는 리포팅 서비스를 운영 중이었습니다. 서비스는 SLA 기준을 충족하고 있었고, 알림도 발생하지 않았습니다. 그러나 가끔씩 응답 지연이 발생한다는 사용자 피드백이 있었습니다.

스레드 덤프를 분석한 결과, 102개의 스레드가 동시에 하나의 락을 기다리고 있었습니다. 문제의 원인은 매우 단순해 보이는 한 줄의 코드였습니다.

## 원인 분석

### Factory 메서드의 숨겨진 비용

자바에서 XML 관련 작업을 할 때 자주 사용하는 DatatypeFactory는 생성 시 복잡한 낮은 수준의 작업을 수행합니다:

1. **ServiceLoader 스캐닝**: META-INF/services 디렉토리를 검색
2. **클스패스 순회**: 모든 JAR 파일을 확인
3. **동기화된 리소스 로딩**: URLClassPath의 synchronized 메서드 호출

이 모든 과정이 스레드 안전을 위해 동기화되어 있어, 동시에 여러 스레드가 접근하면 경합이 발생합니다.

### JVM 낮은 수준의 락

JVM은 클래스로더 리소스 접근을 관리하기 위해 낮은 수준의 락을 사용합니다. ServiceLoader를 통해 팩토리를 생성할 때마다 이 락을 획득하려고 시도하며, 이것이 병목 현상을 만듭니다.

## 해결 방법

### 1. 팩토리 인스턴스 캐싱

가장 효과적인 해결책은 팩토리 인스턴스를 한 번만 생성하고 재사용하는 것입니다:

```java
private static final DatatypeFactory DATATYPE_FACTORY;

static {
    try {
        DATATYPE_FACTORY = DatatypeFactory.newInstance();
    } catch (DatatypeConfigurationException e) {
        throw new RuntimeException("팩토리 초기화 실패", e);
    }
}
```

이 방식은 클래스 로딩 시 단 한 번만 ServiceLoader 작업을 수행하므로, 런타임 중에는 락 경합이 완전히 사라집니다.

### 2. 정적 리소스 캐싱

애플리케이션에 포함된 파일 리소스를 반복적으로 읽는 경우, Caffeine과 같은 고성능 캐시 라이브러리를 활용합니다:

```java
private final Cache<String, String> resourceCache = Caffeine.newBuilder()
    .maximumSize(100)
    .expireAfterWrite(60, TimeUnit.MINUTES)
    .build();
```

## 적용 결과

| 지표 | 개선 전 | 개선 후 |
|------|---------|---------|
| 블록된 스레드 (최대) | 102개 | 0-2개 |
| 클래스로더 락 경합 | 높음 | 무시할 수준 |
| 파일 읽기 (12시간) | 3400만 회 | 약 100회 |
| 팩토리 인스턴스 생성 | 수백만 회 | 1회 |

## 핵심 교훈

1. **팩토리 메서드는 묶은 것이 아닙니다**: DatatypeFactory, DocumentBuilderFactory 등은 유연성을 위해 설계되었지 성능을 위해 설계되지 않았습니다.

2. **클스로더 작업은 동기화됩니다**: getResource(), loadClass() 등의 작업은 잠재적으로 락 경합을 일으킬 수 있습니다.

3. **스레드 덤프는 이야기를 말해줍니다**: 정기적인 스레드 덤프 분석은 예상치 못한 병목 현상을 발견하는 데 필수적입니다.

4. **정적 리소스는 캐싱하세요**: 런타임에 변경되지 않는 리소스는 한 번만 읽어 재사용하는 것이 좋습니다.

## 검출 방법

### 스레드 덤프 분석

다음 패턴을 찾으세요:
- BLOCKED 상태의 다수 스레드
- URLClassPath, ServiceLoader, ClassLoader가 포함된 스택 트레이스
- 동일한 락 객체를 기다리는 스레드들

### Java Flight Recorder

JFR을 활성화하여 락 경합 이벤트와 클래스로더 활동을 모니터링하세요:

```bash
java -XX:StartFlightRecording=duration=60s,filename=recording.jfr ...
```

## 결론

고성능 Java 서비스에서는 보이지 않는 곳에서 성능 저하가 발생할 수 있습니다. 단순해 보이는 한 줄의 코드가 시스템 전체를 느리게 만들 수 있습니다. ServiceLoader 기반 팩토리 메서드는 정적 초기화로 캐싱하고, 클래스로더 접근은 최소화하는 것이 중요합니다. 정기적인 스레드 덤프 분석은 이러한 문제를 조기에 발견하는 데 큰 도움이 됩니다.
