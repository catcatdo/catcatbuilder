<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Actions로 시작하는 CI/CD 자동화 - 배포 걱정 끝! | 릴황 블로그</title>
    <meta name="description" content="GitHub Actions 입문 가이드. CI/CD 파이프라인 구축, 자동 테스트, 빌드, 배포 설정 방법과 실전 팁을 상세히 설명합니다.">
    <meta property="og:title" content="GitHub Actions로 시작하는 CI/CD 자동화 - 배포 걱정 끝!">
    <meta property="og:description" content="GitHub Actions 입문 가이드. CI/CD 파이프라인 구축, 자동 테스트, 빌드, 배포 설정 방법과 실전 팁을 상세히 설명합니다.">
    <meta property="og:image" content="images/post-github-actions-20260219.jpg">
    <link rel="stylesheet" href="blog.css">
</head>
<body>
    <article class="blog-post">
        <header class="post-header">
            <h1>GitHub Actions로 시작하는 CI/CD 자동화 - 배포 걱정 끝!</h1>
            <div class="post-meta">
                <span class="date">2026-02-19</span>
                <span class="category">기술</span>
                <span class="author">릴황</span>
            </div>
        </header>
        
        <img src="images/post-github-actions-20260219.jpg" alt="GitHub Actions CI/CD 자동화 개념 이미지" class="post-image">
        
        <div class="post-content">
            <h2>왜 CI/CD가 필요할까?</h2>
            <p>개발자들이 가장 귀찮아하는 작업 중 하나가 배포야. 코드 작성하고 테스트해서 깃허브에 푸시했는데, 이걸 서버에 올리려면 SSH로 접속해서 git pull 하고, 의존성 설치하고, 빌드하고, 서버 재시작하고... 이 과정이 하루에 몇 번씩 반복되면 정말 지치거든. 나도 예전에는 매번 수동으로 배포했는데, 실수도 많이 하고 시간도 많이 잡아먹더라고.</p>
            
            <p>그래서 CI/CD를 도입했어. CI/CD가 뭔지 모르는 사람들을 위해 간단히 설명하자면, Continuous Integration(지속적 통합)과 Continuous Deployment(지속적 배포)의 약자야. 코드를 깃허브에 푸시하면 자동으로 테스트하고 빌드해서 서버에 배포해주는 시스템이거든. 한번 설정핣რ두면 그냥 코드만 집중하면 돼.</p>
            
            <p>GitHub Actions는 깃허브에서 공식 제공하는 CI/CD 도구야. 별도의 서버나 Jenkins 같은 걸 설치할 필요 없이, 깃허브 저장소 안에서 바로 설정할 수 있거든. 묶으로 사용할 수 있는 시간도 꽤 많아서 개인 프로젝트나 소규모 팀에서는 충분해.</p>
            
            <p>오늘은 GitHub Actions의 기본 개념부터 실제로 워크플로우를 만드는 방법, 그리고 내가 실제로 쓰고 있는 실전 팁까지 모두 공유할게. 이 글을 읽고 나면 당장 오늘부터 자동 배포를 시작할 수 있을 거야.</p>
            
            <h2>워크플로우 파일 만들기</h2>
            <p>GitHub Actions는 YAML 파일로 설정해. 저장소 루트에 <code>.github/workflows</code> 폴터를 만들고, 거기에 <code>.yml</code> 파일을 만들면 돼. 파일명은 아무거나 상관없는데, 나는 보통 <code>deploy.yml</code>이나 <code>ci.yml</code>처럼 직관적으로 짓거든.</p>
            
            <p>기본적인 구조를 보여줄게:</p>
            
            <pre><code>name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Build
      run: npm run build</code></pre>
            
            <p>각 부분을 설명해줄게. <code>name</code>은 워크플로우의 이름이야. 깃허브에서 Actions 탭에 표시되는 이름이거든. <code>on</code>은 언제 이 워크플로우를 실행할지 정하는 부분이야. 위 예시에서는 main 브랜치에 push되거나 pull_request가 생성될 때 실행되게 했어.</p>
            
            <p><code>jobs</code>는 실제로 실행할 작업들이야. 하나의 워크플로우에 여러 job을 정의할 수 있거든. <code>runs-on</code>은 어떤 환경에서 실행할지 정하는 거야. ubuntu-latest는 최신 우분투 환경이고, windows-latest나 macos-latest도 쓸 수 있어.</p>
            
            <p><code>steps</code>는 job 안에서 순서대로 실행할 단계들이야. 각 step은 <code>uses</code>나 <code>run</code>을 써서 정의해. <code>uses</code>는 GitHub Marketplace에 올라와 있는 공식 액션이나 커뮤니티 액션을 쓰는 거야. <code>actions/checkout@v4</code>는 저장소 코드를 체크아웃하는 공식 액션이거든. <code>run</code>은 직접 쉘 명령어를 실행하는 거야.</p>
            
            <h2>실전 꿀팁들</h2>
            <p>첫 번째 팁은 캐싱을 활용하는 거야. npm install이나 pip install 같은 건 매번 실행하면 시간이 오래 걸리거든. <code>actions/cache</code>를 쓰면 의존성을 캐싱해서 다음 실행 때 재사용할 수 있어. 빌드 시간이 절반으로 줄어들 수 있거든.</p>
            
            <pre><code>- name: Cache dependencies
  uses: actions/cache@v3
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-</code></pre>
            
            <p>두 번째 팁은 시크릿을 활용하는 거야. API 키나 비밀번호 같은 민감한 정보는 코드에 직접 쓰면 안 되잖아. 깃허브 저장소 Settings > Secrets and variables > Actions 에서 시크릿을 등록하면, 워크플로우에서 <code>${{ secrets.SECRET_NAME }}</code> 이렇게 참조할 수 있어. 안전하게 관리할 수 있거든.</p>
            
            <p>세 번째 팁은 배포 단계를 추가하는 거야. 테스트와 빌드가 성공하면 자동으로 서버에 배포하고 싶을 거야. SSH를 통한 배포는 <code>appleboy/ssh-action</code>을 쓰면 쉽게 할 수 있어. 또는 AWS, Azure, Vercel 같은 클라우드 서비스용 액션들도 많으니까 찾아볼면 돼.</p>
            
            <h2>자주 하는 실수와 해결법</h2>
            <p>첫 번째 실수는 브랜치 조건을 안 걸어서 모든 푸시에 실행되는 거야. 위 예시처럼 <code>branches: [ main ]</code> 조건을 꼭 걸어야 해. 그렇지 않으면 feature 브랜치에서 테스트용으로 푸시할 때도 워크플로우가 실행돼서 묶로 사용량을 낭비할 수 있거든.</p>
            
            <p>두 번째 실수는 job 간 데이터 공유를 안 해서 빌드한 파일을 배포하지 못하는 거야. 여러 job으로 나누면 각 job은 독립적인 환경에서 실행되거든. 빌드 결과물을 다음 job에서 쓰려면 <code>actions/upload-artifact</code>로 업로드하고, <code>actions/download-artifact</code>로 다운로드해야 해.</p>
            
            <pre><code>- name: Upload build artifacts
  uses: actions/upload-artifact@v3
  with:
    name: build-files
    path: ./dist

# 다른 job에서
- name: Download build artifacts
  uses: actions/download-artifact@v3
  with:
    name: build-files</code></pre>
            
            <p>세 번째 실수는 에러 처리를 안 해서 실패하도 모르는 거야. <code>continue-on-error: true</code>를 쓰면 해당 step이 실패하도 워크플로우가 계속 실행돼. 의도적으로 그렇게 해야 할 때가 아니라면 쓰지 말고, 문제가 있으면 바로 실패하게 두는 게 좋아.</p>
            
            <h2>트리거 종류와 활용</h2>
            <p>GitHub Actions는 다양한 이벤트로 트리거할 수 있어. push와 pull_request 말고도 많거든. 예를 들어 <code>schedule</code>을 쓰면 크론처럼 주기적으로 실행할 수 있어. 매일 밤 12시에 백업하거나, 주말에 주간 리포트를 생성하는 식으로 활용할 수 있어.</p>
            
            <pre><code>on:
  schedule:
    - cron: '0 0 * * *'  # 매일 자정에 실행</code></pre>
            
            <p><code>workflow_dispatch</code>를 추가하면 깃허브 UI에서 수동으로 실행 버튼을 누를 수도 있어. 테스트할 때나, 배포 타이밍을 사람이 결정해야 할 때 유용하거든. release가 생성될 때 실행하는 <code>release</code> 트리거도 자주 써.</p>
            
            <h2>마무리 - 오늘부터 자동화하기</h2>
            <p>오늘 GitHub Actions의 기본 개념부터 실전 팁까지 알려줬어. 처음에는 YAML 문법이 낯설게 느껴질 수 있지만, 한두 번 써볼면 금방 익숙해질 거야. 특히 자동화의 편리함을 한번 경험하면 수동 배포로는 못 돌아갈 거야.</p>
            
            <p>오늘 배운 내용을 정리하면: 워크플로우 파일을 만들고, 언제 실행할지(on) 정하고, 어떤 작업(jobs)을 할지 정의하는 거야. 캐싱으로 빌드 속도를 높이고, 시크릿으로 민감한 정보를 안전하게 관리하는 거지. 그리고 배포 단계를 추가해서 완전 자동화하는 거야.</p>
            
            <p>처음에는 테스트와 빌드만 자동화하는 것부터 시작하봐. 익숙해지면 배포까지 연결하면 돼. GitHub Actions는 묶로 플랜도 꽤 넉넉해서 개인 프로젝트용으로는 완전 묶로 쓸 수 있거든.</p>
            
            <p>추가로 궁금한 점이나 에러가 해결되지 않으면 댓글로 물어봐줘. GitHub Actions 관련 팁이나 고급 주제들도 더 써볼 수 있어. 그럼 오늘도 행복한 자동화 되길 바랄게! 다음에는 Docker와 GitHub Actions를 함께 쓰는 방법에 대해 글을 써볼까 하는데, 관심 있으면 알려줘.</p>
        </div>
        
        <footer class="post-footer">
            <div class="tags">
                <span class="tag">GitHub Actions</span>
                <span class="tag">CI/CD</span>
                <span class="tag">DevOps</span>
                <span class="tag">자동화</span>
                <span class="tag">배포</span>
            </div>
        </footer>
    </article>
    
    <script>
        // 다크모드 감지
        if (localStorage.getItem('theme') === 'dark' || 
            (!localStorage.getItem('theme') && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark-theme');
        }
    </script>
</body>
</html>
